{% extends "base.html" %}

{% block title %}Messages - Job.it{% endblock %}

{% block navbar_extra %}
    <div class="position-absolute top-50 start-50 translate-middle">
        {% if user.appuser.role == 'recruiter' %}
            <button type="button" class="btn btn-secondary me-2" onclick="window.location.href='/'">Candidates</button>
            <button type="button" class="btn btn-secondary" onclick="window.location.href='/listings'">My Listings</button>
        {% else %}
            <button type="button" class="btn btn-secondary me-2" onclick="window.location.href='/'">Search Jobs</button>
            <button type="button" class="btn btn-secondary" onclick="window.location.href='/worker_profile'">My Profile</button>
        {% endif %}
    </div>
{% endblock %}

{% block content %}
<style>
    /* Light hover effects for chat message bubbles */
    .message-bubble {
        transition: all 0.15s ease;
        cursor: pointer;
    }
    
    .message-bubble:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }
    
    .message-bubble.sent:hover {
        box-shadow: 0 2px 6px rgba(13, 110, 253, 0.15);
    }
    
    .message-bubble.received:hover {
        box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }
    
    .message-bubble.new-message {
        animation: newMessagePulse 2s ease-in-out;
        border-left: 3px solid #0d6efd;
    }
    
    @keyframes newMessagePulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.02); }
        100% { transform: scale(1); }
    }
    
    .message-bubble.new-message::before {
        content: "NEW";
        position: absolute;
        top: -8px;
        left: 10px;
        background: #0d6efd;
        color: white;
        font-size: 0.6rem;
        padding: 2px 6px;
        border-radius: 10px;
        font-weight: bold;
    }
    
    .conversation-item {
        transition: background-color 0.2s ease;
        cursor: pointer;
    }
    
    .conversation-item:hover {
        background-color: #f8f9fa !important;
    }
    
    .conversation-item.active {
        background-color: #e3f2fd !important;
        border-left: 4px solid #0d6efd;
    }
    
    .conversation-item.active:hover {
        background-color: #e3f2fd !important;
    }
    
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #6c757d;
    }
    
    .empty-state i {
        font-size: 4rem;
        margin-bottom: 1rem;
    }
    
    .message-input {
        resize: none;
        border: none;
        outline: none;
        box-shadow: none;
    }
    
    .message-input:focus {
        box-shadow: none;
        border-color: #dee2e6;
    }
    

</style>

<div class="container-fluid">
    <div class="row" style="height: calc(100vh - 156px);">
        <!-- Contacts List -->
        <div class="col-md-4 col-lg-3 border-end p-0" style="height: 100%;">
            <div class="d-flex flex-column h-100">
                <div class="p-3 border-bottom">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Messages</h5>
                    </div>
                </div>
                <div class="overflow-auto flex-grow-1">
                    <div class="list-group list-group-flush" id="conversationsList">
                        <!-- Conversations will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="col-md-8 col-lg-9 p-0" style="height: 100%;">
            <div class="d-flex flex-column h-100">
                <!-- Chat Header with Context -->
                <div class="p-3 border-bottom bg-light" id="chatHeader" style="display: none;">
                    <div class="d-flex align-items-center justify-content-between">
                        <div class="d-flex align-items-center">
                            <div id="chatAvatar" class="avatar-placeholder primary me-3">
                                <i class="bi bi-person-fill fs-4"></i>
                            </div>
                            <div>
                                <h5 class="mb-0" id="chatName">John Doe</h5>
                                <div class="d-flex align-items-center gap-2">
                                    <span class="badge bg-info text-dark" id="chatPosition">Senior Software Engineer</span>
                                    <span class="badge bg-success" style="font-size: 0.7rem;" id="chatRemote" style="display: none;">Remote</span>
                                    <span class="badge bg-warning" style="font-size: 0.7rem;" id="chatHybrid" style="display: none;">Hybrid</span>
                                </div>
                            </div>
                        </div>
                        <div class="text-end">
                            <small class="text-muted d-block" id="chatJobPosition">Position: Senior Developer</small>
                            <small class="text-muted d-block" id="chatCompany">Company: TechCorp Inc.</small>
                            <small class="text-muted d-block" id="chatJobLocation">Location: Lodz, Poland</small>
                            <div class="mt-1" id="chatLocationTags">
                                <!-- Location tags will be added here -->
                            </div>
                            <div class="mt-2">
                                <button class="btn btn-outline-primary btn-sm" id="viewJobButton" onclick="viewJobListing()" title="View Job Listing">
                                    <i class="bi bi-briefcase me-1"></i>View Job
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Empty State -->
                <div class="empty-state" id="emptyState">
                    <i class="bi bi-chat-dots"></i>
                    <h4>No conversation selected</h4>
                    <p>Choose a conversation from the list to start messaging</p>
                </div>

                <!-- Messages Area -->
                <div class="flex-grow-1 overflow-auto p-3" id="messagesArea" style="display: none;">
                    <!-- New Messages Indicator -->
                    <div id="newMessagesIndicator" class="text-center mb-3" style="display: none; position: sticky; top: 0; z-index: 10; background: white; padding: 10px 0;">
                        <div class="alert alert-primary d-inline-flex align-items-center" role="alert" style="cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,0.1);" onclick="scrollToBottom()">
                            <i class="bi bi-arrow-down-circle me-2 fs-5"></i>
                            <strong>New messages received!</strong>
                            <span class="ms-2">Click to view</span>
                        </div>
                    </div>
                    <div id="messagesContainer">
                        <!-- Messages will be loaded here -->
                    </div>
                </div>

                <!-- Message Input -->
                <div class="p-3 border-top" id="messageInput" style="display: none;">
                    <div class="input-group">
                        <input type="text" class="form-control" id="messageText" placeholder="Type a message...">
                        <button class="btn btn-primary" id="sendButton" onclick="sendMessage()">
                            <i class="bi bi-send"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let currentConversationId = null;
    let currentJobListingId = null;
    let conversations = [];
    let lastReadTime = null;
    let readTimeout = null;
    
    // Initialize the chat interface
    document.addEventListener('DOMContentLoaded', function() {
        loadConversations();
        updateNotifications(); // Initial notification update
        

        
        // Send message on Enter
        const messageText = document.getElementById('messageText');
        messageText.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Auto-refresh conversations every 10 seconds
        setInterval(() => {
            if (!currentConversationId) {
                // Only refresh conversations if no conversation is selected
                loadConversations();
            }
        }, 10000);
        
        // Auto-refresh messages every 5 seconds if conversation is selected
        setInterval(() => {
            if (currentConversationId) {
                loadMessages(currentConversationId, true);
            }
        }, 5000);
        
        // Update notifications every 3 seconds (even when window is not focused)
        setInterval(() => {
            updateNotifications();
        }, 3000);
        
        // Add event listeners for user activity
        document.addEventListener('visibilitychange', checkUserActivity);
        document.addEventListener('focus', checkUserActivity);
        document.addEventListener('mousemove', throttledCheckUserActivity);
        document.addEventListener('keydown', throttledCheckUserActivity);
        document.addEventListener('scroll', throttledCheckUserActivity);
    });
    
    // Load conversations from API
    function loadConversations() {
        fetch('/messages/conversations/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': CSRF_TOKEN,
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                conversations = data.data;
                renderConversations();
                
                // If there's a currently selected conversation, make sure its badge is hidden
                if (currentConversationId) {
                    const conversationElement = document.querySelector(`[data-conversation-id="${currentConversationId}"]`);
                    if (conversationElement) {
                        const badge = conversationElement.querySelector('.badge');
                        if (badge) {
                            badge.style.display = 'none';
                        }
                    }
                }
                
                // Update global notifications after loading conversations
                updateNotifications();
            } else {
                console.error('Failed to load conversations:', data.message);
            }
        })
        .catch(error => {
            console.error('Error loading conversations:', error);
        });
    }
    
    // Render conversations list
    function renderConversations() {
        const conversationsList = document.getElementById('conversationsList');
        conversationsList.innerHTML = '';
        
        if (conversations.length === 0) {
            conversationsList.innerHTML = `
                <div class="p-3 text-center text-muted">
                    <i class="bi bi-chat-dots fs-1"></i>
                    <p class="mt-2">No conversations yet</p>
                </div>
            `;
            return;
        }
        
        conversations.forEach(conversation => {
            const conversationElement = createConversationElement(conversation);
            conversationsList.appendChild(conversationElement);
        });
    }
    
    // Create conversation list item
    function createConversationElement(conversation) {
        const div = document.createElement('div');
        div.className = 'list-group-item list-group-item-action p-3 conversation-item';
        div.dataset.conversationId = conversation.id;
        div.onclick = () => selectConversation(conversation.id);
        
        const avatarColors = ['primary', 'success', 'warning', 'danger', 'info', 'secondary'];
        const avatarColor = avatarColors[conversation.id % avatarColors.length];
        
        const lastMessage = conversation.last_message.content || 'No messages yet';
        const lastMessageTime = conversation.last_message.created_at ? 
            new Date(conversation.last_message.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
        
        // Create avatar HTML - use profile photo if available, otherwise use placeholder
        let avatarHtml;
        if (conversation.other_user.profile_photo) {
            avatarHtml = `<img src="data:image/jpeg;base64,${conversation.other_user.profile_photo}" class="rounded-circle me-3" style="width: 48px; height: 48px; object-fit: cover;" alt="Profile Photo">`;
        } else {
            avatarHtml = `<img src="/static/images/avatar.png" class="rounded-circle me-3" style="width: 48px; height: 48px; object-fit: cover;" alt="Profile Photo">`;
        }
        
        div.innerHTML = `
            <div class="d-flex w-100 justify-content-between align-items-center">
                <div class="d-flex align-items-center">
                    ${avatarHtml}
                    <div>
                        <h6 class="mb-1 ${conversation.unread_count > 0 ? 'fw-bold' : ''}">${conversation.other_user.name}</h6>
                        <p class="mb-1 text-muted small">${conversation.other_user.position || 'No position'}</p>
                        <small class="${conversation.unread_count > 0 ? 'fw-bold text-dark' : 'text-muted'}">${lastMessage.substring(0, 30)}${lastMessage.length > 30 ? '...' : ''}</small>
                    </div>
                </div>
                <div class="text-end">
                    ${conversation.unread_count > 0 ? `<span class="badge bg-primary rounded-pill ms-2">${conversation.unread_count}</span>` : ''}
                    <div class="text-muted small">${lastMessageTime}</div>
                </div>
            </div>
        `;
        
        return div;
    }
    
    // Select a conversation
    function selectConversation(conversationId) {
        currentConversationId = conversationId;
        
        // Update active state in conversation list
        document.querySelectorAll('.conversation-item').forEach(item => {
            item.classList.remove('active');
        });
        document.querySelector(`[data-conversation-id="${conversationId}"]`).classList.add('active');
        
        // Show chat interface
        document.getElementById('emptyState').style.display = 'none';
        document.getElementById('chatHeader').style.display = 'block';
        document.getElementById('messagesArea').style.display = 'block';
        document.getElementById('messageInput').style.display = 'block';
        
        // Load conversation details and messages
        loadConversationDetails(conversationId);
        loadMessages(conversationId);
        
        // Mark conversation as read when selected
        setTimeout(() => {
            markConversationAsRead(conversationId);
        }, 500);
        
        // Hide the unread badge
        const conversationElement = document.querySelector(`[data-conversation-id="${conversationId}"]`);
        if (conversationElement) {
            const badge = conversationElement.querySelector('.badge');
            if (badge) {
                badge.style.display = 'none';
            }
        }
    }
    
    // Load conversation details for header
    function loadConversationDetails(conversationId) {
        const conversation = conversations.find(c => c.id == conversationId);
        if (!conversation) return;
        
        // Store the job listing ID for the view button
        currentJobListingId = conversation.job_listing.id;
        
        // Update header information
        document.getElementById('chatName').textContent = conversation.other_user.name;
        document.getElementById('chatPosition').textContent = conversation.other_user.position || 'No position';
        document.getElementById('chatJobPosition').textContent = `Position: ${conversation.job_listing.title}`;
        document.getElementById('chatCompany').textContent = `Company: ${conversation.job_listing.company}`;
        document.getElementById('chatJobLocation').textContent = `Location: ${conversation.job_listing.location || 'Location not specified'}`;
        
        // Add location tags based on job model
        const locationTagsContainer = document.getElementById('chatLocationTags');
        locationTagsContainer.innerHTML = '';
        
        // Add job model tags (Remote, Hybrid, etc.)
        if (conversation.job_listing.job_model) {
            const jobModel = conversation.job_listing.job_model.toLowerCase();
            if (jobModel === 'remote') {
                locationTagsContainer.innerHTML += '<span class="badge bg-success me-1" style="font-size: 0.7rem;">Remote</span>';
            } else if (jobModel === 'hybrid') {
                locationTagsContainer.innerHTML += '<span class="badge bg-warning me-1" style="font-size: 0.7rem;">Hybrid</span>';
            } else if (jobModel === 'stationary') {
                locationTagsContainer.innerHTML += '<span class="badge bg-info me-1" style="font-size: 0.7rem;">On-site</span>';
            }
        }
        
        // Update avatar - use profile photo if available, otherwise use placeholder
        const avatar = document.getElementById('chatAvatar');
        
        if (conversation.other_user.profile_photo) {
            avatar.className = 'me-3';
            avatar.innerHTML = `<img src="data:image/jpeg;base64,${conversation.other_user.profile_photo}" class="rounded-circle" style="width: 48px; height: 48px; object-fit: cover;" alt="Profile Photo">`;
        } else {
            avatar.className = 'me-3';
            avatar.innerHTML = `<img src="/static/images/avatar.png" class="rounded-circle" style="width: 48px; height: 48px; object-fit: cover;" alt="Profile Photo">`;
        }
        
        // Show/hide remote/hybrid badges (placeholder - would need user data)
        document.getElementById('chatRemote').style.display = 'none';
        document.getElementById('chatHybrid').style.display = 'none';
    }
    
    // Load messages for a conversation
    function loadMessages(conversationId, isAutoRefresh = false) {
        fetch(`/messages/conversations/${conversationId}/messages/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': CSRF_TOKEN,
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                const messagesContainer = document.getElementById('messagesContainer');
                
                if (data.data.messages.length === 0) {
                    // Show placeholder for empty conversation
                    messagesContainer.innerHTML = `
                        <div class="d-flex justify-content-center mb-3">
                            <div class="bg-light rounded p-3 message-bubble received" style="max-width: 75%;">
                                <p class="mb-0">This conversation was started from a job application.</p>
                                <small class="text-muted">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</small>
                            </div>
                        </div>
                    `;
                } else {
                    if (!isAutoRefresh) {
                        // Initial load - clear and show all messages
                        messagesContainer.innerHTML = '';
                        data.data.messages.forEach(message => {
                            const messageTime = new Date(message.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                            addMessageToUI(message.content, message.is_sent_by_me, messageTime, message.id);
                        });
                    } else {
                        // Auto-refresh - only add new messages
                        const existingMessageIds = new Set(
                            Array.from(messagesContainer.querySelectorAll('[data-message-id]'))
                                .map(el => el.dataset.messageId)
                        );
                        
                        const newMessages = data.data.messages.filter(message => 
                            !existingMessageIds.has(message.id.toString())
                        );
                        
                        newMessages.forEach(message => {
                            const messageTime = new Date(message.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                            addMessageToUI(message.content, message.is_sent_by_me, messageTime, message.id, true); // Mark as new message
                        });
                        
                        // Show new messages indicator if new messages arrived and user is not at bottom
                        if (newMessages.length > 0) {
                            const messagesArea = document.getElementById('messagesArea');
                            const isAtBottom = messagesArea.scrollTop + messagesArea.clientHeight >= messagesArea.scrollHeight - 100;
                            
                            console.log('New messages arrived:', newMessages.length);
                            console.log('Is at bottom:', isAtBottom);
                            console.log('Scroll position:', messagesArea.scrollTop, messagesArea.scrollHeight);
                            
                            if (!isAtBottom) {
                                console.log('Showing new messages indicator');
                                showNewMessagesIndicator();
                            } else {
                                console.log('User is at bottom, not showing indicator');
                            }
                        }
                        
                    }
                }
                
                // Scroll to bottom only if user is near bottom or it's initial load
                const messagesArea = document.getElementById('messagesArea');
                if (!isAutoRefresh || messagesArea.scrollTop + messagesArea.clientHeight >= messagesArea.scrollHeight - 100) {
                    messagesArea.scrollTop = messagesArea.scrollHeight;
                }
            } else {
                console.error('Failed to load messages:', data.message);
            }
        })
        .catch(error => {
            console.error('Error loading messages:', error);
            if (!isAutoRefresh) {
                // Show error message only on initial load
                const messagesContainer = document.getElementById('messagesContainer');
                messagesContainer.innerHTML = `
                    <div class="d-flex justify-content-center mb-3">
                        <div class="bg-light rounded p-3 message-bubble received" style="max-width: 75%;">
                            <p class="mb-0">Error loading messages. Please try again.</p>
                            <small class="text-muted">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</small>
                        </div>
                    </div>
                `;
            }
        });
    }
    
    // Send a message
    function sendMessage() {
        if (!currentConversationId) return;
        
        const messageText = document.getElementById('messageText');
        const content = messageText.value.trim();
        
        if (!content) return;
        
        // Disable send button and show loading
        const sendButton = document.getElementById('sendButton');
        const originalContent = sendButton.innerHTML;
        sendButton.innerHTML = '<i class="bi bi-hourglass-split"></i>';
        sendButton.disabled = true;
        
        // Send message to API
        fetch('/messages/send-message/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': CSRF_TOKEN,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                conversation_id: currentConversationId,
                content: content
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Add message to UI with the new message ID
                addMessageToUI(content, true, null, data.data.message_id);
                
                // Clear input
                messageText.value = '';
                
                // Refresh conversations to update last message
                loadConversations();
                
                // Pause auto-refresh briefly to prevent immediate duplication
                setTimeout(() => {
                    if (currentConversationId) {
                        loadMessages(currentConversationId, true);
                    }
                }, 2000);
            } else {
                console.error('Failed to send message:', data.message);
                alert('Failed to send message. Please try again.');
            }
        })
        .catch(error => {
            console.error('Error sending message:', error);
            alert('Error sending message. Please try again.');
        })
        .finally(() => {
            // Restore send button
            sendButton.innerHTML = originalContent;
            sendButton.disabled = false;
        });
    }
    
    // Add message to UI
    function addMessageToUI(content, isSent, customTime = null, messageId = null, isNewMessage = false) {
        const messagesContainer = document.getElementById('messagesContainer');
        const messageDiv = document.createElement('div');
        messageDiv.className = `d-flex justify-content-${isSent ? 'end' : 'start'} mb-3`;
        
        const bubbleClass = isSent ? 'bg-primary text-white' : 'bg-light';
        const timeClass = isSent ? 'text-white-50' : 'text-muted';
        const messageTime = customTime || new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const newMessageClass = isNewMessage && !isSent ? 'new-message' : '';
        
        messageDiv.innerHTML = `
            <div class="${bubbleClass} rounded p-3 message-bubble ${isSent ? 'sent' : 'received'} ${newMessageClass}" style="max-width: 75%; position: relative;" ${messageId ? `data-message-id="${messageId}"` : ''}>
                <p class="mb-0">${content}</p>
                <small class="${timeClass}">${messageTime}</small>
            </div>
        `;
        
        messagesContainer.appendChild(messageDiv);
        
        // Scroll to bottom only if not auto-refresh
        if (!messageId) {
            const messagesArea = document.getElementById('messagesArea');
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }
        
        // Note: New message styling will be removed when user interacts with conversation
        // (clicking, scrolling, or any activity in the conversation window)
    }
    
    // Mark conversation as read
    function markConversationAsRead(conversationId) {
        if (!conversationId) return;
        
        fetch(`/messages/conversations/${conversationId}/mark-read/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': CSRF_TOKEN,
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Update the conversation list to reflect read status
                loadConversations();
                
                // Also update the current conversation's unread count in the UI
                const conversationElement = document.querySelector(`[data-conversation-id="${conversationId}"]`);
                if (conversationElement) {
                    const badge = conversationElement.querySelector('.badge');
                    if (badge) {
                        badge.style.display = 'none';
                    }
                }
            }
        })
        .catch(error => {
            console.error('Error marking conversation as read:', error);
        });
    }
    
    // Track previous notification state to detect changes
    let previousNotificationState = {
        hasUnread: false,
        unreadCount: 0
    };
    
    // Update notification badges globally
    function updateNotifications() {
        fetch('/messages/notifications/', {
            method: 'GET',
            headers: {
                'X-CSRFToken': CSRF_TOKEN,
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                const unreadCount = data.data.unread_messages_count;
                const hasUnread = data.data.has_unread_messages;
                
                // Check if notification state changed
                const stateChanged = (
                    previousNotificationState.hasUnread !== hasUnread ||
                    previousNotificationState.unreadCount !== unreadCount
                );
                
                // Update menu burger notification badge (same as base.html)
                const menuBadge = document.getElementById('messageNotificationBadge');
                if (menuBadge) {
                    if (hasUnread) {
                        menuBadge.textContent = '!';
                        menuBadge.style.display = 'block';
                    } else {
                        menuBadge.style.display = 'none';
                    }
                }
                
                // Update messages menu badge (same as base.html)
                const messagesMenuBadge = document.getElementById('messagesMenuBadge');
                if (messagesMenuBadge) {
                    if (hasUnread) {
                        messagesMenuBadge.textContent = unreadCount;
                        messagesMenuBadge.style.display = 'block';
                    } else {
                        messagesMenuBadge.style.display = 'none';
                    }
                }
                
                // Update page title if there are unread messages
                updatePageTitle(hasUnread, unreadCount);
                
                // Store current state for next comparison
                previousNotificationState = {
                    hasUnread: hasUnread,
                    unreadCount: unreadCount
                };
            }
        })
        .catch(error => {
            console.error('Error updating notifications:', error);
        });
    }
    
    // Update page title to show unread count
    function updatePageTitle(hasUnread, unreadCount) {
        const originalTitle = 'Messages - Job.it';
        
        if (hasUnread) {
            document.title = `(${unreadCount}) ${originalTitle}`;
        } else {
            document.title = originalTitle;
        }
    }
    
    // Check if user is actively viewing the conversation
    function checkUserActivity() {
        if (currentConversationId && document.visibilityState === 'visible') {
            // Clear existing timeout
            if (readTimeout) {
                clearTimeout(readTimeout);
            }
            
            // Set a new timeout to mark as read after 1 second of activity
            readTimeout = setTimeout(() => {
                markConversationAsRead(currentConversationId);
            }, 1000);
            
            // Remove new message styling when user interacts with conversation
            removeNewMessageStyling();
        }
    }
    
    // Remove new message styling from all messages
    function removeNewMessageStyling() {
        const newMessageBubbles = document.querySelectorAll('.message-bubble.new-message');
        newMessageBubbles.forEach(bubble => {
            bubble.classList.remove('new-message');
        });
    }
    
    // Throttled version of checkUserActivity to prevent too many calls
    let activityThrottle = null;
    function throttledCheckUserActivity() {
        if (activityThrottle) return;
        
        activityThrottle = setTimeout(() => {
            checkUserActivity();
            activityThrottle = null;
        }, 200); // Throttle to 200ms
    }
    
    // Show new messages indicator
    function showNewMessagesIndicator() {
        const indicator = document.getElementById('newMessagesIndicator');
        console.log('showNewMessagesIndicator called, indicator found:', !!indicator);
        if (indicator) {
            indicator.style.display = 'block';
            console.log('New messages indicator should now be visible');
        } else {
            console.error('New messages indicator element not found!');
        }
    }
    
    // Hide new messages indicator
    function hideNewMessagesIndicator() {
        const indicator = document.getElementById('newMessagesIndicator');
        if (indicator) {
            indicator.style.display = 'none';
        }
    }
    
    // Scroll to bottom of messages
    function scrollToBottom() {
        const messagesArea = document.getElementById('messagesArea');
        messagesArea.scrollTop = messagesArea.scrollHeight;
        hideNewMessagesIndicator();
    }
    
    // View job listing in new tab
    function viewJobListing() {
        if (currentJobListingId) {
            window.open(`/listings/${currentJobListingId}`, '_blank');
        } else {
            console.error('No job listing ID available');
        }
    }
    

</script>
{% endblock %} 